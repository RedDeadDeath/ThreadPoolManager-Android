№1

---------------------------
| ThreadPoolManager Manual |
---------------------------

ThreadPoolManager - это класс для управления пулом потоков и выполнения задач асинхронно. Он поддерживает выполнение задач типа Runnable и Callable, возможность приостановки/возобновления работы пула потоков, а также задержки выполнения.

---------------------------------------------------------------
| Основные функции ThreadPoolManager:                        |
---------------------------------------------------------------
1. `execute(Runnable task)` - Выполняет задачу типа Runnable.
2. `execute(Callable<T> task)` - Выполняет задачу типа Callable, которая возвращает результат.
3. `delay(long timeMillis)` - Задержка выполнения действия на заданное время.
4. `executeWithUiUpdate(Runnable backgroundTask, Runnable uiUpdateTask, boolean runOnMainThread)` - Выполняет задачу в фоновом потоке и обновляет UI.
5. Методы для приостановки/возобновления пула потоков:
   - `pause()` - Приостанавливает пул потоков.
   - `resume()` - Возобновляет работу пула потоков.
   - `isPaused()` - Проверяет, приостановлен ли пул потоков.
6. `close()` - Завершается работа пула потоков.

---------------------------------------------------------------
| Пример использования ThreadPoolManager:                      |
---------------------------------------------------------------
 


public class Main {
    public static void main(String[] args) {
        // Создание контекста (например, в Android приложении)
        Context context = ...; // Замените на реальный контекст приложения в Android

        // Создание ThreadPoolManager с контекстом устройства
        ThreadPoolManager threadPoolManager = new ThreadPoolManager(context);

        // Задача типа Runnable
        Runnable task = () -> {
            System.out.println("Задача выполняется в фоновом потоке...");
        };

        // Запуск задачи
        ThreadPoolJob job1 = threadPoolManager.execute(task);

        // Проверка состояния выполнения задачи
        job1.awaitCompletion(); // Ждем завершения задачи
    }
}



№2


================================================================================
ThreadPoolManagerScope - Ручное управление потоками с использованием пула
================================================================================

Описание:
-----------
`ThreadPoolManagerScope` - это класс, который помогает организовать работу с пулами потоков в Java. 
Он позволяет запускать задачи в контексте определенного скоупа, обеспечивая контроль за их состоянием.
Каждый скоуп может иметь дочерние скоупы, которые следуют правилам родительского скоупа. 
Когда скоуп закрывается, все дочерние скоупы также закрываются, а все запущенные задачи отменяются.

Класс реализует интерфейс `AutoCloseable`, что позволяет использовать его с конструкцией try-with-resources.

================================================================================
Параметры класса:
-------------------
1. `threadPoolManager` - Менеджер пула потоков, который управляет задачами.
2. `parentScope` - Родительский скоуп для вложенных скоупов.

================================================================================
Методы:
--------

1. `public boolean isActive()`
    - Проверяет, активен ли скоуп. Возвращает `true`, если скоуп активен и родительский скоуп тоже активен.

2. `public ThreadPoolJob launch(Runnable task)`
    - Запускает задачу типа `Runnable` в пуле потоков, привязанную к данному скоупу.
    - Возвращает объект `ThreadPoolJob`, который можно использовать для отслеживания состояния задачи.

3. `public <T> CompletableFuture<T> async(Callable<T> task)`
    - Запускает асинхронную задачу типа `Callable`, которая возвращает результат.
    - Возвращает объект `CompletableFuture<T>`, с которым можно работать как с асинхронным результатом.

4. `public ThreadPoolManagerScope createChildScope()`
    - Создает дочерний скоуп, который будет наследовать поведение родительского скоупа.

5. `@Override public void close()`
    - Закрывает скоуп, отменяя все задачи и освобождая ресурсы.

6. `public void cancelAllJobs()`
    - Отменяет все активные задачи, привязанные к скоупу.

7. `private void trackJob(ThreadPoolJob job)`
    - Отслеживает задачу, добавляя обработчики завершения и отмены.

8. `private void handleException(Throwable e, Consumer<Throwable> handler)`
    - Обрабатывает исключения, передавая их в глобальный обработчик ошибок или в локальный обработчик задачи.

9. `private void startAutoCleanup()`
    - Автоматически очищает завершенные задачи через каждые 5 секунд.

================================================================================
Пример использования:
----------------------

Пример 1: Запуск задач в скоупе
-------------------------------

public class Main {
    public static void main(String[] args) {
        // Создание пула потоков
        ThreadPoolManager threadPoolManager = new ThreadPoolManager(4);

        // Создание скоупа
        try (ThreadPoolManagerScope scope = new ThreadPoolManagerScope(threadPoolManager, null)) {
            
            // Запуск задачи без обработки исключений
            ThreadPoolJob job1 = scope.launch(() -> {
                System.out.println("Задача 1 выполняется...");
                Thread.sleep(1000); // имитируем выполнение
            });

            // Запуск асинхронной задачи с обработчиком исключений
            CompletableFuture<String> future = scope.async(() -> {
                System.out.println("Асинхронная задача выполняется...");
                Thread.sleep(500); // имитируем выполнение
                return "Результат задачи";
            });

            future.thenAccept(result -> System.out.println("Результат: " + result));

            // Ожидание завершения всех задач
            job1.awaitCompletion();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Описание:
-----------
1. Создаем `ThreadPoolManager` с 4 потоками.
2. Внутри блока `try-with-resources` создаем скоуп `ThreadPoolManagerScope`, который автоматически закроется в конце блока.
3. В скоупе запускаем задачу типа `Runnable` с помощью метода `launch()`.
4. Также запускаем асинхронную задачу типа `Callable` с помощью метода `async()`, результат которой выводится по завершению.
5. После завершения всех задач скоуп будет автоматически закрыт, и все ресурсы будут освобождены.

================================================================================
Ошибки и исключения:
---------------------
- `IllegalArgumentException`: Выбрасывается, если передана `null` задача или пул потоков.
- `IllegalStateException`: Выбрасывается, если попытаться запустить задачу в неактивном скоупе.
- `CancellationException`: Выбрасывается, если скоуп отменен, а задача все еще выполняется.
- `CancellationException`: Возникает при отмене задачи, если скоуп был закрыт.
  
 

№3.
---------------------------
|    ThreadDispatchers Manual    |
---------------------------

ThreadDispatchers - это набор диспетчеров для выполнения задач асинхронно в различных потоках:
- IO поток (неограниченный пул потоков)
- Главный поток (UI поток)
- Основной пул потоков (для задач, которые требуют интенсивной работы с процессором)

---------------------------------------------------------------
| Основные функции ThreadDispatchers:                          |
---------------------------------------------------------------
1. `IO` - Диспетчер для ввода-вывода (неограниченный пул потоков для IO задач).
2. `MAIN` - Диспетчер для главного потока (UI).
3. `DEFAULT(Context context)` - Диспетчер для задач, требующих интенсивного использования процессора.
4. `CancellableTask` - Задача, которая может быть отменена.
   - `cancel()` - Отменяет задачу.
   - `isCancelled()` - Проверяет, была ли задача отменена.
   - `onComplete(Runnable callback)` - Регистрация колбека для завершения задачи.
   - `onCancel(Runnable callback)` - Регистрация колбека для отмены задачи.
   - `onError(Consumer<Throwable> callback)` - Регистрация колбека для обработки ошибок.
5. `trackTask(Object scope, CancellableTask task)` - Отслеживает задачу, привязанную к объекту (например, Activity или ViewModel).
6. `cancelScope(Object scope)` - Отменяет все задачи, привязанные к объекту.

---------------------------------------------------------------
| Пример использования ThreadDispatchers:                        |
---------------------------------------------------------------

1. **Запуск задачи в фоновом потоке с использованием IO диспетчера:**

 
public class Main {
    public static void main(String[] args) {
        // Задача для фона
        Runnable backgroundTask = () -> {
            System.out.println("Фоновая задача выполняется...");
        };

        // Запуск задачи в IO потоке
        CancellableTask cancellableTask = ThreadDispatchers.IO.execute(backgroundTask);

        // Добавление колбеков
        cancellableTask.onComplete(() -> {
            System.out.println("Задача завершена.");
        }).onError(e -> {
            System.err.println("Ошибка выполнения: " + e.getMessage());
        });
    }
}

2.Запуск задачи в главном потоке (UI) с использованием MAIN диспетчера:

public class Main {
    public static void main(String[] args) {
        // Задача для фона
        Runnable backgroundTask = () -> {
            System.out.println("Фоновая задача выполняется...");
        };

        // Задача для обновления UI
        Runnable uiUpdateTask = () -> {
            System.out.println("Обновление UI после фоновой задачи...");
        };

        // Запуск задачи в фоновом потоке и обновление UI в главном потоке
        CancellableTask cancellableTask = ThreadDispatchers.MAIN.execute(() -> {
            backgroundTask.run();
            // Обновление UI
            uiUpdateTask.run();
        });

        // Ожидание завершения задачи
        cancellableTask.onComplete(() -> {
            System.out.println("Задача и обновление UI завершены.");
        });
    }
}
3.Запуск задачи с расчетом оптимального размера пула потоков для CPU задач с использованием DEFAULT диспетчера:

public class Main {
    public static void main(String[] args) {
        // Создание контекста
        Context context = ...; // Укажите контекст вашего приложения (например, в Android)

        // Запуск задачи с использованием CPU-интенсивного пула потоков
        Runnable cpuTask = () -> {
            System.out.println("Интенсивная задача для процессора...");
        };

        // Создание диспетчера с контекстом устройства
        ExecutorService defaultExecutor = ThreadDispatchers.DEFAULT(context);

        // Выполнение задачи
        CancellableTask cancellableTask = new CancellableTask(cpuTask);
        defaultExecutor.submit(cancellableTask);

        // Ожидание завершения задачи
        cancellableTask.onComplete(() -> {
            System.out.println("CPU задача завершена.");
        }).onError(e -> {
            System.err.println("Ошибка при выполнении задачи: " + e.getMessage());
        });
    }
}
4.
Отслеживание задач, привязанных к объекту (например, к Activity):
public class Main {
    public static void main(String[] args) {
        // Создание объекта для отслеживания (например, Activity)
        Object scope = new Object();

        // Задача для выполнения
        Runnable task = () -> {
            System.out.println("Задача выполняется...");
        };

        // Создание и выполнение отслеживаемой задачи
        CancellableTask cancellableTask = ThreadDispatchers.Default(scope, task);

        // Регистрация колбеков
        cancellableTask.onComplete(() -> {
            System.out.println("Задача завершена.");
        }).onCancel(() -> {
            System.out.println("Задача отменена.");
        });

        // Отменить все задачи в указанном объекте
        ThreadDispatchers.cancelScope(scope);
    }
}

| Основные понятия: |

CancellableTask: Задача, которая может быть отменена в процессе выполнения.

Scope: Объект, к которому привязаны задачи (например, Activity или ViewModel), для которых задачи могут быть отслежены и отменены.

Диспетчеры: Используются для выполнения задач в различных потоках:

IO: для ввода-вывода (IO задачи).

MAIN: для главного потока (обновление UI).

DEFAULT: для интенсивных CPU задач.

| Закрытие пула потоков: |
В конце работы с ThreadDispatchers рекомендуется закрывать пул потоков с помощью метода close(), чтобы освободить ресурсы.

ThreadDispatchers.close();


### Объяснение:

- **ThreadDispatchers** предоставляет несколько диспетчеров:
  - `IO`: Используется для ввода-вывода, где важна производительность ввода/вывода.
  - `MAIN`: Диспетчер для работы в главном потоке, что полезно для обновления UI в приложениях.
  - `DEFAULT`: Для задач, которые требуют много ресурсов процессора, и их выполнение должно быть ограничено числом ядер процессора.

- **CancellableTask** позволяет добавлять колбеки для выполнения задач, отмены задач и обработки ошибок. Также задачи можно привязать к объектам (например, к Activity), чтобы контролировать их выполнение и отмену.
