┌──────────────────────┬───────────────────────────┬───────────────────────┬───────────────────────┬───────────────────────┐
│       Функция        │   ThreadPoolManager       │   Handler + Runnable  │      Coroutines       │    ExecutorService    │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Управление пулом     │ ✅ Автонастройка под      │ ❌ Нет управления     │ ✅ Dispatchers (IO,   │ ✅ Ручная настройка   │
│ потоков              │    устройство             │                       │    Default, Main)     │    пула               │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Отмена задач         │ ✅ ThreadPoolJob.cancel() │ ❌ Только             │ ✅ Job.cancel()       │ ✅ Future.cancel()    │
│                      │                           │   removeCallbacks()   │                       │                       │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Пауза/возобновление  │ ✅ pause()/resume()      │ ❌ Невозможно         │ ❌ Нет (но можно      │ ❌ Невозможно         │
│                      │                           │                       │   через Job)          │                       │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Обработка ошибок     │ ✅ Логирование и         │ ❌ Нет механизма      │ ✅ try/catch в        │ ✅ try/catch         │
│                      │    обработка исключений   │                       │   корутинах           │                       │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Обновление UI        │ ✅ runOnUiThread()       │ ✅ handler.post()     │ ✅ Dispatchers.Main   │ ❌ Требуется Handler  │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ Язык                 │ ✅ Java + Kotlin         │ ✅ Java + Kotlin      │ ❌ Только Kotlin      │ ✅ Java + Kotlin      │
├──────────────────────┼───────────────────────────┼───────────────────────┼───────────────────────┼───────────────────────┤
│ CPU-intensive задачи │ ✅ Оптимизировано        │ ❌ Не рекомендуется   │ ⚠️ Dispatchers.Default│ ✅ Подходит           │
└──────────────────────┴───────────────────────────┴───────────────────────┴───────────────────────┴───────────────────────┘

=== Рекомендации по выбору ===

1. Для Kotlin-проектов:
   - Лучший выбор: Coroutines (+ Flow для потоков данных)
   - Причины: легковесность, structured concurrency, интеграция с Jetpack

2. Для Java-проектов или сложной многопоточности:
   - Лучший выбор: ThreadPoolManager
   - Альтернатива: ExecutorService (если не нужны дополнительные фичи)

3. Для простых фоновых задач:
   - Handler + Runnable (устаревший, но простой)
   - Для новых проектов лучше использовать Coroutines даже для простых задач

4. Для CPU-heavy операций:
   - ThreadPoolManager или ExecutorService с FixedThreadPool
   - В Coroutines - Dispatchers.Default (ограничен CPU-ядрами)

=== Примеры использования ===

◆ ThreadPoolManager (Java/Kotlin):
ThreadPoolManager manager = new ThreadPoolManager();
manager.submitTask(() -> {
    // Фоновая работа
    runOnUiThread(() -> textView.setText("Done"));
});

◆ Coroutines (Kotlin):
viewModelScope.launch(Dispatchers.IO) {
    val data = fetchData()
    withContext(Dispatchers.Main) {
        textView.text = data
    }
}

◆ Handler (устаревший способ):
Handler(Looper.getMainLooper()).postDelayed({
    textView.text = "Updated"
}, 1000);

◆ ExecutorService (базовый):
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.execute(() -> {
    // Фоновая работа
    runOnUiThread(() -> textView.setText("Done"));
});

